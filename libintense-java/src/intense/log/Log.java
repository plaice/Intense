// ****************************************************************************
//
// Log.java - Simple, threadsafe logging with timestamps.
//
// Copyright 2002 by Paul Swoboda.  All Rights Reserved.
//
// This file is part of the Intense project.
//
// Intense is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// Intense is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Intense; if not, write to the Free Software Foundation, Inc.,
// 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
//
// ****************************************************************************


package intense.log;


import java.lang.*;
import java.util.*;
import java.util.concurrent.locks.*;
import java.text.*;
import java.io.*;
import intense.*;


public class Log {

  protected static SimpleDateFormat dateFormatter =
    new SimpleDateFormat("yyyy/MM/dd HH:mm:ss:SSS");

  /**
   * The most significant log priority.  Never use this unless you really mean
   * it.  Notify-the-president level.
   */
  public static final int CATASTROPHIC = 0;

  /**
   * A log priority indicating complete system failure.
   */
  public static final int FATAL = 1;

  /**
   * A log priority indicating complete near or imminent system failure.
   */
  public static final int CRITICAL = 2;

  /**
   * A log priority indicating a serious error.
   */
  public static final int ERROR = 3;

  /**
   * A log priority indicating a minor error.
   */
  public static final int WARN = 4;

  /**
   * A log priority indicating a trivial, potentially frequent notice.
   */
  public static final int NOTICE = 5;

  /**
   * A log priority indicating the first level of debugging - major cases only.
   */
  public static final int DEBUG = 6;

  /**
   * A log priority indicating the second level of debugging - more debugging
   * than DEBUG.
   */
  public static final int DEBUG1 = 7;

  /**
   * A log priority indicating the highest level of debugging - more debugging
   * than DEBUG1.
   */
  public static final int DEBUG2 = 8;

  /**
   * The higest (least significant) log priority, where everything than can be
   * logged, is.
   */
  public static final int MAX = 9;

  /**
   * Check the validity of a log priority integer.
   *
   * @param prioirty The priority to validate.
   */
  public static void checkPriority
  (int priority)
    throws LogException
  {
    if ((priority < CATASTROPHIC)||(priority > MAX)) {
      throw new LogException("Invalid priority " + priority);
    }
  }

  /**
   * Get a string equivalent for a log priority integer.
   *
   * @param prioirty The priority to convert to a string representation.
   * @return The string equivalent of the given priority.
   */
  public static String toPriorityString
  (int priority)
    throws LogException
  {
    checkPriority(priority);
    return priorityStrings[priority];
  }

  protected static String[] priorityStrings = {
    "CATASTROPHIC", "FATAL", "CRITICAL", "ERROR", "WARN", "NOTICE", "DEBUG",
    "DEBUG1", "DEBUG2", "MAX"
  };

  // messages (in full form) are of the form:
  // [yyyy/mm/dd hh:mm:ss:mss] [LEVEL] Message message message...

  protected java.util.Date timestamp;

  protected LogStream logStream;

  protected StringBuffer message;

  protected int priority;

  protected int defaultPriority;

  protected boolean messageStarted;

  protected boolean autoTimestamp;

  protected ReentrantLock mutex;

  private Log
  ()
  {}

  protected void updateTimestamp
  ()
  {
    timestamp = new java.util.Date();
  }

  protected void lock
  ()
  {
    if (!mutex.isHeldByCurrentThread()) {
      mutex.lock();
    }
  }

  protected void unlock
  ()
  {
    mutex.unlock();
  }

  /**
   * @param logStream The target LogStream for this Log.
   */
  public Log
  (LogStream logStream)
  {
    this.logStream = logStream;
    message = new StringBuffer();
    defaultPriority = NOTICE;
    messageStarted = false;
    autoTimestamp = true;
    mutex = new ReentrantLock();
    priority = defaultPriority;
  }

  /**
   * Set the default priority of log messages generated by this Log.
   *
   * @param defaultPriority The new priority.
   */
  public void setDefaultPriority
  (int defaultPriority)
  {
    this.defaultPriority = defaultPriority;
  }

  /**
   * Overrides auto-timestamping for the current message (done at the end
   * of the message), setting the timestamp for the message to the time of
   * call to stampTime().
   */
  public void stampTime
  ()
  {
    lock();
    updateTimestamp();
    autoTimestamp = false;
  }

  /**
   * Append to the current message.
   */
  public Log add
  (boolean b)
  {
    lock();
    message.append(b);
    return this;
  }

  /**
   * Append to the current message.
   */
  public Log add
  (char c)
  {
    lock();
    message.append(c);
    return this;
  }

  /**
   * Append to the current message.
   */
  public Log add
  (char[] s)
  {
    lock();
    message.append(s);
    return this;
  }

  /**
   * Append to the current message.
   */
  public Log add
  (double d)
  {
    lock();
    message.append(d);
    return this;
  }

  /**
   * Append to the current message.
   */
  public Log add
  (float f)
  {
    lock();
    message.append(f);
    return this;
  }

  /**
   * Append to the current message.
   */
  public Log add
  (int i)
  {
    lock();
    message.append(i);
    return this;
  }

  /**
   * Append to the current message.
   */
  public Log add
  (long l)
  {
    lock();
    message.append(l);
    return this;
  }

  /**
   * Append to the current message.
   */
  public Log add
  (Object obj)
  {
    lock();
    message.append(obj.toString());
    return this;
  }

  /**
   * Append to the current message.
   */
  public Log add
  (String s)
  {
    lock();
    message.append(s);
    return this;
  }

  /**
   * This changes the priority of the current log message, which is changed
   * back to the default priority at the start of the next message.
   */
  public Log priority
  (int priority)
  {
    lock();
    this.priority = priority;
    return this;
  }

  /**
   *
   *
   * This terminates the current log message and writes it to the
   * underlying ostream - if stampTime() was not called during the message,
   * a timestamp is generated.
   *
   * Usage:
   *
   * log.add("The value is ").add(value).add("!").end();
   */
  public void end
  ()
  {
    lock();
    logStream.lock();
    if (!(logStream.isOpen())) {
      unlock();
      logStream.unlock();
      return;
    }
    if (logStream.logLevel >= priority) {
      PrintStream streamRef = logStream.streamRef();
      if (logStream.useTimestamps) {
        if (autoTimestamp) {
          updateTimestamp();
        }
        streamRef.print("[");
        streamRef.print(dateFormatter.format(timestamp));
        streamRef.print("] ");
      }
      if (logStream.usePriorities) {
        streamRef.print("[");
        streamRef.print(priorityStrings[priority]);
        streamRef.print("] ");
      }
      streamRef.println(message.toString());
      streamRef.flush();
    }
    logStream.unlock();
    autoTimestamp = true;
    message = new StringBuffer();
    priority = defaultPriority;
    unlock();
  }

  /**
   * Get the stack trace of a Throwable as a String.
   *
   * @param t The Throwable from which to obtain a stack trace.
   * @return The stack trace, as a multi-line string.
   */
  public static String getTrace
  (Throwable t)
  {
    ByteArrayOutputStream traceBytes = new ByteArrayOutputStream();
    PrintStream traceOut = new PrintStream(traceBytes);

    try {
      t.printStackTrace(traceOut);
      traceOut.flush();
      traceBytes.flush();
      return traceBytes.toString();
    } catch (IOException ignored) {
      return "getStackTrace() failed!";
    }
  }

}
